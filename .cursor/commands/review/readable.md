# リーダブルコードレビュー

## 概要

コードの可読性、保守性、理解しやすさに焦点を当てたコードレビューを実施します。変数名、関数名、コード構造、コメント、複雑度などを評価し、改善提案を行います。

## パラメータ

| パラメータ | 型     | 必須   | 説明                                                                                                                                                                  |
| ---------- | ------ | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 手順番号   | string | はい   | レビューするチェックリストの番号（例：`all`、`1`、`1.7`、`3.5`など）。チェックリスト全体（`all`）またはカテゴリ全体（`1`）または特定のチェック項目（`1.7`）を指定可能 |
| diff       | string | いいえ | `diff`を指定すると、gitの差分があるファイルのみをレビュー対象とする                                                                                                   |

## 手順

1. **対象ファイルの決定**
   - `diff`フラグが指定されている場合：
     - `git diff HEAD --name-only`を実行して、変更されたファイルのリストを取得する（ステージ済みと未ステージの両方の変更を含む）
     - 取得したファイルのみをレビュー対象とする
   - `diff`フラグが指定されていない場合：
     - ユーザーがディレクトリを指定している場合は、そのディレクトリ内のすべてのファイルをレビュー対象とする
     - ユーザーがファイルを指定している場合は、そのファイルをレビュー対象とする
     - 何も指定されていない場合は、現在開いているファイルをレビュー対象とする
   - **テストコードの除外**：
     - 以下の条件に該当するファイルはレビュー対象から除外する：
       - ファイルパスに `test`, `tests`, `__tests__`, `spec`, `specs` が含まれるディレクトリ内のファイル
       - ファイル名に `.test.`, `.spec.` が含まれるファイル（例：`user.test.js`, `user.spec.ts`）
       - ファイル名が `test` または `spec` で始まる、または終わるファイル

2. **指定された手順番号のチェック項目に基づいたレビュー**
   - 手順番号を解析する：
     - `1.7`のように小数点が含まれる場合：該当する特定のチェック項目（例：1.7）のみを評価する
     - `1`のように整数のみの場合：該当カテゴリ（例：カテゴリ1）のすべてのチェック項目を評価する
     - `all`の場合：チェックリスト全体のすべてのチェック項目を評価する
   - 特定されたチェック項目を対象ファイルに対して評価する
   - 各チェック項目に違反している箇所を特定する

3. **改善提案の提示**
   - 優先度（高/中/低）を付けて、優先度の高い順に並べる
   - 優先度（高/中）のみを表示する
   - 違反内容と改善案のコード例を提示

## 使用例

### 基本的な使用例（カテゴリ1のすべてのチェック項目をレビュー）

```
/review/readable 1
```

### 特定のチェック項目をレビュー（1.7のみ）

```
/review/readable 1.7
```

### ディレクトリを指定してレビュー

```
/review/readable 2 src/components
```

### git差分があるファイルのみをレビュー（カテゴリ2のチェック項目）

```
/review/readable 2 diff
```

### 特定のチェック項目とgit差分チェックフラグの組み合わせ

```
/review/readable 3.5 diff
```

### ディレクトリ指定とgit差分チェックフラグの組み合わせ（diffフラグが優先される）

```
/review/readable 4 diff
```

## チェックリスト

**注意**：関数とは、クラスメソッドを含みます

- 1 **ファイル、変数、関数、クラスなどの命名規則**
  - 1.1 抽象的(Get, Foo)や複数の解釈ができる単語を使ってはいけないこと
  - 1.2 関数は具体的に何をするのかを誤解せずに名前から読み取れること
  - 1.3 関数名と使用目的が一致していること
  - 1.4 booleanの変数、関数は具体的な用途・目的を誤解せずに名前から読み取れること
  - 1.5 接尾辞や接頭辞を使って単位や属性情報を追加していること
  - 1.6 10行以上のスコープ内でvやiなどの名前入を使っていないこと
  - 1.7 なくても理解できる単語は削ること（ConvertToStringはToStringにできる）
  - 1.8 名前のフォーマットに一貫性があること
  - 1.9 境界値を示す単語は(min,max)(first,last)(begin,end)などを使い、「以下」と「未満」の違いがわかるようにすること

- 2 **外観**
  - 2.1 定義の並び順は一貫性を持たせること
  - 2.2 定義と処理は意味のあるグループごとに段落を分けること

- 3 **クラス、関数、変数、段落コメント**
  - 3.1 コードからすぐに分かる（ジュニアエンジニアが1秒以下で理解できること）コメントは削除すること
    - ただし、3.3に当てはまるものは対象外とする
  - 3.2 複雑な内容（ジュニアエンジニアが理解に10秒以上かかる）はコメントを書くこと
  - 3.3 クラス名、関数名(コンストラクタは対象外)、プロパティ名、定数名の日本語コメントを書くこと
  - 3.4 実装意図が分かりづらい、または特殊なものにはコメントを書くこと
  - 3.5 改善が必要な箇所には`TODO:`コメントを書くこと
  - 3.6 未完成の箇所には`TODO:`コメントを書くこと
  - 3.7 定数は、なぜその値にしたのか不明な場合にはコメントを書くこと
  - 3.8 「それ」や「これ」などの曖昧な代名詞は名詞に書き換えること
  - 3.9 誤解や複数の解釈ができるコメントは書き換えること
  - 3.10 説明が複雑な関数コメントは実例も書くこと

- 4 **制御フロー(if,for,while)**
  - 4.1 条件式は左が調査対象、右が比較対象になっていること
  - 4.2 条件は下記で最も効果的な書き方になっていること
    - 条件は否定形より肯定形を使うこと
    - 単純な条件を先に書くこと
    - 関心ごとの高い条件を先に書くこと
  - 4.3 2つの値から1つを選ぶような単純な条件は三項演算子,null合体演算子,エルビス演算子を使うこと
  - 4.4 do/whileループや疑似do/whileはwhileループに書き直すこと
  - 4.5 適切にガード節を使うこと
  - 4.6 ネストは浅くすること
    - 失敗ケースは早い段階で`return`する
    - ループ内部のifはできる限り`continue`をつかう

- 5 **式のサイズ**
  - 5.1 複雑な式は説明クラスメソッドを作ること
  - 5.2 複雑な論理式は要約クラスメソッドを作ること
  - 5.3 固定値は説明変数または定数を作ること

- 6 **変数**
  - 6.1 簡潔で、明確で、一度しか使われていない式の一時変数は作らないこと
  - 6.2 中間結果を保持する変数は、使わずに実装できないか考えること
  - 6.3 制御フロー変数は、使わずに実装できないか考えること
  - 6.4 クラスのプロパティは、クラスメソッドのローカル引数にできないか考えること
  - 6.5 クラスメソッドはstaticにできないか考えること
  - 6.6 変数への代入は1度だけとすること

- 7 **関数**
  - 7.1 下位目的を解決するためのコードは別の関数にすること
    - 関数コメントの内容が上位目的となる
    - 取得、セット、更新、削除、変換、除外、事前処理、事後処理などが下位目的になりやすい
    - 例：上位目的が「2点の距離を求める」ならば、下位目的は2点の距離を求めるために、「点をラジアンに変換する」
  - 7.2 一つの関数で一つの目的のみを達成すること（コントローラのメソッドは含めない）
  - 7.3 コードの１行１行が簡単な言葉で説明できる内容であること

## チェック項目の相反する場合の判断基準

- **1.7（冗長な単語の削除）と1.1, 1.2（動作の明確性）が相反する場合**：
  - 型情報（戻り値の型、`async` キーワードなど）やコンテキスト（関数の使用箇所、引数の型など）から動作が明確に推測できる場合は、**1.7を優先**して冗長な動詞（`get`, `fetch`, `create`, `build` など）を削除することを推奨
  - 例：`async channelNames(...): Promise<string[]>` のように、戻り値の型から「取得する」動作が明確な場合、`getChannelNames` ではなく `channelNames` で十分
  - 例：`convertXToY` のように `To` や `From` などの接頭辞/接尾辞で変換の方向性が明確な場合、`convert` は冗長な可能性がある
- **1.1, 1.2を優先すべき場合**：
  - 型情報やコンテキストだけでは動作が不明確な場合（例：名詞のみの関数名で、設定・取得・検証など複数の解釈が可能な場合）
  - ただし、その場合でも1.7の原則を考慮し、最小限の動詞を追加する（例：`get` より `fetch` の方が適切な場合もあるが、簡潔さを優先）
- **1.7（簡潔性）と1.8（一貫性）が相反する場合**：
  - プロジェクト全体で一貫した命名規則（例：すべての取得関数に `get` プレフィックスを使用）が確立されている場合は、**1.8を優先**して一貫性を保つ
  - ただし、新規コードやリファクタリングの機会では、1.7の原則を適用してより簡潔な命名を検討する余地がある
  - 例：既存コードベース全体で `getUser()`, `getProduct()` という命名規則が一貫している場合、新規の `getChannelNames()` もこの規則に従う（1.8優先）

- **6.1（一時変数を作らない）と5.1, 5.2, 5.3（複雑な式を説明する）が相反する場合**：
  - 6.1は「簡潔で、明確で、一度しか使われていない式の一時変数は作らない」としているが、5.1, 5.2, 5.3は複雑な式を説明するために変数やメソッドを作ることを推奨している
  - **複雑さを基準に判断**：式が複雑で理解に時間がかかる場合（5.1, 5.2, 5.3の基準）は、説明変数やメソッドを作成することを推奨
  - 簡潔で明確な式の場合は、6.1に従って一時変数を作らない
  - 例：`const result = a + b;` のような単純な式は一時変数不要（6.1適用）
  - 例：`const isValid = user.age >= 18 && user.hasLicense && !user.isSuspended;` のような複雑な論理式は説明変数を作成（5.2適用）

- **4.2の3つの条件（単純な条件を先に書く vs 関心ごとの高い条件を先に書く）が相反する場合**：
  - 「単純な条件を先に書く」と「関心ごとの高い条件を先に書く」は相反する可能性がある
  - **優先順位**：1. 関心ごとの高い条件を先に書く、2. 単純な条件を先に書く
  - ただし、関心ごとの高い条件が複雑な場合は、ガード節（4.5）や説明変数（5.2）を使用して可読性を保つ
  - 例：`if (user.isAdmin && complexPermissionCheck())` より `if (user.isAdmin && hasComplexPermission(user))` のように説明メソッドを使用

- **7.1（関数を分割）と7.2（一つの目的のみ）のバランス**：
  - 7.1は関数を分割することを推奨し、7.2は一つの目的のみを達成することを推奨している
  - これらは補完的だが、**過度な分割は避ける**：関数を細かく分割しすぎると、逆に可読性が下がる可能性がある
  - 判断基準：関数が「1行1行が簡単な言葉で説明できる内容」（7.3）であり、かつ「一つの目的のみを達成」（7.2）している場合、さらに分割する必要はない
  - 例：3行程度の単純な関数をさらに分割する必要はない
