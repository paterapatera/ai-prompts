# SOLIDコードレビュー

## 概要

SOLID原則に基づいて、ソフトウェアのコンポーネント構造を評価し、改善案を提案します。

## パラメータ

| パラメータ | 型     | 必須   | 説明                                                                                                |
| ---------- | ------ | ------ | --------------------------------------------------------------------------------------------------- |
| 原則       | string | いいえ | 評価する原則を指定（`S`、`O`、`L`、`I`、`D`、または`all`）。指定がない場合は`all`として全原則を評価 |
| diff       | string | いいえ | `diff`を指定すると、gitの差分があるファイルのみをレビュー対象とする                                 |

## 手順

**モジュール**とは、ソースファイルのことである。

1. **対象ファイルの決定**
   - `diff`フラグが指定されている場合：
     - `git diff HEAD --name-only`を実行して、変更されたファイルのリストを取得する（ステージ済みと未ステージの両方の変更を含む）
     - 取得したファイルのみをレビュー対象とする
   - `diff`フラグが指定されていない場合：
     - ユーザーがディレクトリを指定している場合は、そのディレクトリ内のすべてのファイルをレビュー対象とする
     - ユーザーがファイルを指定している場合は、そのファイルをレビュー対象とする
     - 何も指定されていない場合は、プロジェクト全体をレビュー対象とする
   - **テストコードの除外**：
     - 以下の条件に該当するファイルはレビュー対象から除外する：
       - ファイルパスに `test`, `tests`, `__tests__`, `spec`, `specs` が含まれるディレクトリ内のファイル
       - ファイル名に `.test.`, `.spec.` が含まれるファイル（例：`user.test.js`, `user.spec.ts`）
       - ファイル名が `test` または `spec` で始まる、または終わるファイル

2. **コンポーネント構造の分析**
   - プロジェクトのディレクトリ構造を分析し、コンポーネント（モジュール、パッケージ、ディレクトリ）を特定する
   - 各コンポーネントに含まれるクラス、モジュール、ファイルをリストアップする
   - コンポーネント間の依存関係をマッピングする
   - 各コンポーネントの変更履歴や変更頻度を分析する（可能な場合）

3. **指定された原則に基づいたレビュー**
   - 原則パラメータを解析する：
     - `S`が指定された場合：単一責任の原則のみを評価する
     - `O`が指定された場合：開放閉鎖の原則のみを評価する
     - `L`が指定された場合：リスコフの置換原則のみを評価する
     - `I`が指定された場合：インターフェース分離の原則のみを評価する
     - `D`が指定された場合：依存関係逆転の原則のみを評価する
     - `all`が指定された場合、または指定がない場合：5つの原則すべてを評価する
   - 各原則に基づいてコンポーネント構造を評価する

4. **原則別の評価と改善提案**
   - **単一責任の原則（SRP）の評価**：
     - クラスやモジュールが単一の責任を持っているか
     - クラスやモジュールの変更理由が一つに限定されているか
     - 違反している箇所を特定し、改善案を提示する
   - **開放閉鎖の原則（OCP）の評価**：
     - クラスやモジュールが拡張に対して開かれているか
     - クラスやモジュールが修正に対して閉じているか
     - 違反している箇所を特定し、改善案を提示する
   - **リスコフの置換原則（LSP）の評価**：
     - サブクラスがスーパークラスの代替として機能するか
     - サブクラスがスーパークラスの期待を裏切らないか
     - 違反している箇所を特定し、改善案を提示する
   - **インターフェース分離の原則（ISP）の評価**：
     - クライアントが使用しないメソッドに依存していないか
     - インターフェースが特定のクライアントに適したものになっているか
     - 違反している箇所を特定し、改善案を提示する
   - **依存関係逆転の原則（DIP）の評価**：
     - 高水準モジュールが低水準モジュールに依存していないか
     - 抽象に依存しているか
     - 違反している箇所を特定し、改善案を提示する

5. **改善提案の提示**
   - 優先度（高/中/低）を付けて、優先度の高い順に並べる
   - 優先度（高/中）のみを表示する
   - 各原則に基づいた改善案を明確に分類して提示
   - 推奨改善案を最初に提示し、その理由を説明
   - 具体的な改善案をコード例や構造図と共に提示

## 使用例

### 基本的な使用例（全原則を評価）

```
/review/architecture
```

### 特定の原則を評価（Sのみ）

```
/review/architecture S
```

### ディレクトリを指定してレビュー

```
/review/architecture all src/components
```

### git差分があるファイルのみをレビュー

```
/review/architecture diff
```

### 特定の原則とgit差分チェックフラグの組み合わせ

```
/review/architecture S diff
```

## 評価原則

**注意**：評価原則は厳守です。勝手に必要ないと判断することを禁じます。

### 単一責任の原則（SRP）

クラスやモジュールは単一の責任を持ち、その責任に関する変更理由は一つに限定されるべきである。

**評価観点**：

- クラスやモジュールが複数の責任を持っていないか
- クラスやモジュールの変更理由が一つに限定されているか
- クラスやモジュールが高凝集であるか

**違反の例**：

- ユーザー管理とメール送信の機能が同じクラスに含まれている
- データアクセスとビジネスロジックが同じモジュールに含まれている

### 開放閉鎖の原則（OCP）

クラスやモジュールは拡張に対して開かれており、修正に対して閉じているべきである。

**評価観点**：

- クラスやモジュールが新しい機能追加のために修正されていないか
- クラスやモジュールが継承やポリモーフィズムを活用して拡張されているか
- クラスやモジュールが設計パターンを適切に利用しているか

**違反の例**：

- 新しい支払い方法を追加するために既存の支払いクラスが修正されている
- 条件分岐が多用されており、新しいケースに対応するたびにコードが変更されている

### リスコフの置換原則（LSP）

サブクラスはスーパークラスの代替として機能し、スーパークラスの期待を裏切らないようにすべきである。

**評価観点**：

- サブクラスがスーパークラスの契約を遵守しているか
- サブクラスがスーパークラスの振る舞いを変更していないか
- サブクラスがスーパークラスの前提条件や事後条件を破っていないか

**違反の例**：

- サブクラスがスーパークラスのメソッドをオーバーライドして、期待される動作を変更している
- サブクラスがスーパークラスの前提条件を強化している

### インターフェース分離の原則（ISP）

クライアントは使用しないメソッドに依存してはならず、インターフェースは特定のクライアントに適したものにすべきである。

**評価観点**：

- クライアントが使用しないメソッドに依存していないか
- インターフェースが特定のクライアントに適したものになっているか
- インターフェースが小さく、特化されているか

**違反の例**：

- 大きなインターフェースを実装するクラスが、使用しないメソッドを持っている
- 複数の異なるクライアントが同じインターフェースを使用しているが、必要なメソッドが異なる

### 依存関係逆転の原則（DIP）

高水準モジュールは低水準モジュールに依存してはならず、両者とも抽象に依存すべきである。

**評価観点**：

- 高水準モジュールが低水準モジュールに依存していないか
- 抽象に依存しているか
- 依存関係注入やサービスロケーターパターンが適切に使用されているか

**違反の例**：

- ビジネスロジックが直接データベースアクセスクラスに依存している
- 具体的な実装クラスに依存しており、抽象に依存していない
