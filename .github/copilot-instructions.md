# Copilot instructions

## Coding Guidelines

### メソッド作成ガイド

- 目的: 新しいユーティリティや処理を追加する際の統一ルールを示します。
- 選択肢: 次のいずれかを実装してください（いずれか一つを選択して作成します）
  - 分岐関数（条件に応じて異なる処理を行う）
  - 要約関数（条件式を返す）
  - 説明関数（1行が100文字を超えるような式や複数行で構成される配列を関数化する）
  - 処理関数（要約関数・分岐関数以外の処理を行う）
  - カリー関数（クロージャを返す関数を生成する）

- 命名と署名の方針:
  - メソッド名は動詞始まりのキャメルケース（例: `summarizeText`）を推奨
  - 可能な限り `public static` として宣言する（ユーティリティ的に呼び出しやすくするため）
  - 入出力はシンプルに：入力は1つのパラメータ（必要ならラッパークラスを使用）、出力は明確な型
  - 例外は明示的にスローする（Checked/Uncheckedをプロジェクト基準に合わせて選択）

#### 分岐関数

if文やtry-catchは分岐関数。
条件式は要約関数に抽出する。
分岐内部は `if-else` を使い、三項演算子は避ける。
スコープ内に書く関数は1つに制限する。

例:

```php
public static function hoge(): int {
  if (isCondition()) {
    return foo();
  } else {
    return bar();
  }
}

public static function hoge2(callable $success, callable $error): int {
  try {
    return $success();
  } catch (SpecificException $e) {
    return $error();
  }
}
```

#### 説明関数

説明関数は1行が100文字を超えるような式や複数行で構成される配列を関数化する。
例:

```php
public static function calculateTotal(array $item): array {
  return [
    $item['price'] * $item['quantity1'],
    $item['price'] * $item['quantity2'],
    $item['price'] * $item['quantity3'],
  ]
}
```

#### 要約関数

要約関数は条件式を返す。

例:

```php
public static function isOwner(User $user): bool {
  return $user->role === 'owner';
}
```

#### 処理関数

要約関数・分岐関数以外はパイプ演算子（`|>`、PHP 8.5 以降で使用可能）でプロセス関数として実装することを推奨する（既存のメソッドチェーンは維持可）。
PHP 8.5 未満の環境ではメソッドチェーンや明示的な関数呼び出しを使用してください。

例 (PHP 8.5+ の場合):

```php
public static function hoge($a, $b) {
  return foo($a, $b)
    |> getAOrB(...)
    |> toFooObject(...)
    |> validateFooObject(...);
}
```

例 (PHP < 8.5 の場合):

```php
public static function hoge($a, $b) {
  $v = foo($a, $b);
  $v = getAOrB($v);
  $v = toFooObject($v);
  return validateFooObject($v);
}
```

---

#### カリー関数

例:

```php
public static function getMonthTotalMapper(array $monthValues): callable {
    return fn(int $month) => self::buildMonthTotalPair($month, $monthValues);
}
```

---

### ファイル分割ガイドライン

**注意**：評価原則は厳守です。勝手に必要ないと判断することを禁じます。
**注意**：ファイルが200行を超える場合、分割を検討してください。

#### 閉鎖性共通の原則（CCP）

同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること。
変更の理由やタイミングが異なるクラスは、別のコンポーネントに分けること。

**評価観点**：

- 同じビジネス要件や技術的要件によって変更されるクラスが同じコンポーネントに属しているか
- 変更履歴が類似しているクラスが同じコンポーネントに属しているか
- 変更の理由が異なるクラスが別のコンポーネントに分かれているか

**違反の例**：

- データベーススキーマ変更とUI変更が同じコンポーネントに含まれている
- 認証ロジックとレポート生成ロジックが同じコンポーネントに含まれている

#### 再利用・リリース等価の原則（REP）

再利用の単位とリリースの単位は等価になること。

**評価観点**：

- コンポーネントが一貫するテーマや目的を持つクラスやモジュールで構成されているか
- コンポーネントがまとめてリリース可能な単位になっているか
- コンポーネントに含まれるクラスやモジュールが適当に寄せ集められていないか

**違反の例**：

- 関連性のないクラスが同じコンポーネントに含まれている
- リリース頻度が大きく異なるクラスが同じコンポーネントに含まれている

#### 全再利用の原則（CRP）

コンポーネントのユーザーに対して、実際には使わないものへの依存を強要しないこと。

**評価観点**：

- 一緒に用いられることが多いクラスやモジュールが同じコンポーネントにまとまっているか
- コンポーネントのユーザーが使わないクラスへの依存を強要されていないか
- 密結合していないクラスが同じコンポーネントにまとめられていないか

**違反の例**：

- コンテナクラスとイテレータが別のコンポーネントに分かれている
- コンポーネントの一部のクラスだけを使いたいのに、全体に依存する必要がある

#### 改善案のスコアリング基準

各改善案に対して以下の基準でスコアを付与します：

##### 影響範囲

- **高**：複数のコンポーネントに影響し、大規模なリファクタリングが必要
- **中**：1〜2つのコンポーネントに影響し、中規模のリファクタリングが必要
- **低**：単一のコンポーネント内での変更で済む

##### 実装難易度

- **高**：複雑な依存関係の解決や大規模なコード移動が必要
- **中**：中程度のリファクタリングと依存関係の調整が必要
- **低**：簡単なファイル移動や軽微な修正で済む

##### 期待される効果

- **高**：アーキテクチャの品質が大幅に向上し、保守性が大きく改善される
- **中**：アーキテクチャの品質が中程度向上し、保守性が改善される
- **低**：アーキテクチャの品質が軽微に向上する

##### 総合スコアの計算

各評価項目を数値化（高=3、中=2、低=1）し、以下の式で計算：

```
総合スコア = (期待される効果 × 2) - (実装難易度 × 1.5) - (影響範囲 × 0.5)
```

最もスコアの高い改善案を推奨改善案として提示します。
